[{"title":"【笔记】AC自动机（ACAM）学习笔记","date":"2026-01-12T12:38:22.000Z","url":"/2026/01/12/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["教程","/tags/%E6%95%99%E7%A8%8B/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"她可不是自动AC机，前者是算法，后者就是作弊了。 前置知识 你至少应该掌握以下算法，以下会跳转到我之前写的笔记。 KMP算法 字典树（Trie） 简介 AC自动机（Aho-Corasick Automaton）是基于Tire树，并结合KMP算法的一种多模式串匹配算法。它可以在 （其中 表示 主串 的长度， 表示一个 模式串 ）的时间复杂度内解决一个这样的问题：给你一个长度为 的主串，和 个模式串，求出每个模式串在主串中出现的次数。 那么，实际上AC自动机是建立在Trie树上的自动机。自动机 在数学上定义如下：判断一个 信号序列 是否满足某种特定模式或规则的数学模型。可以简易理解成，将一个状态转换成另一个状态的一种算法，例如动态规划的转移过程，就是一个自动机。 我们回忆传统的KMP算法，它只能解决一个模式串的问题，其思想核心是我们在字符串 失配 后，利用了预处理的 的数组，使得我们可以不再重新比较，而是直接跳跃到 数组中的一个位置，节省了大量时间，详情见上文链接。 详解 构建Trie树（insert） 第一步，我们首先对于所有模式串，构建一棵Trie树，如图1所示。 图1 假设我们需要做到可以在主串中找到如图几个字符串。 特殊地，推荐在画图时将字母标到边上，方便理解和观察。 代码和普通Trie的插入是一样的，如下。 最重要！构建失配指针（build p1） 第二步，我们回想KMP，发现我们可以仿照KMP的思想，也去构建一个 失配指针 ，来记录当我们匹配失败时，我们该何去何从。但这样未免过于功利性，我们要结合实际的问题。思考，当我们失配时，我们可能会跳到哪个节点？显然，我们跳到的节点，应该包含我们此时所在的节点。当然，如果能顺便包含现在节点的父亲、祖父、所有祖先……就更好了，所以新串无论如何，都必然是原串的一个 后缀 ！ 我们定义 表示 从根节点（ ）到当前节点 的串在Trie中的节点 ，满足从根节点到该节点的串，是原串中的最长后缀 ，即到达节点 并失配时，我们应该跳转到的节点编号。至于最长，是为了保证我们在失配后能 丢失最少的信息 ，尽快进行下一次匹配，以降低时间复杂度。配合图2，绿色箭头为 回跳边 ，即 数组的值。 图2 假设节点 的父亲节点为 ，有如下方程 不理解？别担心，再来举个栗子，我们看下面的图3. 图3 假设我们现在已经知道了父亲 的 数组值，那么我们考虑把其转移到孩子 ，为了方便，我们先假设 的孩子和 相同（不相同的情况我们接下来讨论），那么事实上，我们构建了一种 映射 关系， 对应 ，那么 也应该对应着 才对。 这就解释了第一个方程，方程左边为 ，右边是 的孩子，因为 和 是父子，根据映射关系，那么 和 也是父子，这样我们就求出 的值了。第二个方程也极好解释，无非就是把 换为 ， 换为 的孩子，道理是一样的，这样做是为了后面代码的方便。 好吧，我知道你还是看不懂，那就再举个栗子。关注图2中的2、3、6、7号节点。首先关注2和6，两个h匹配。假设我们在6号节点这里失配，我们可以转移到2号节点，继续下面的匹配，留得青山在，不怕没柴烧嘛！至于上面的方程，我们观察3和7，我们已经知道了 ，也就是7号节点e的父亲h可以转移到2号节点h上，那么对应起来，7号e也应该能跟着转移到3号e上，这样， 就等于 了。 代码会在p2章节放出，因为我们还需要构建转移边。 建立转移边（build p2） 那么，如果孩子不对应呢？接下来就来到第三步了，我们需要考虑构建不存在的边，来防止上面的情况，也就是构建 转移边 。 还是图2，考虑我们现在要匹配串“sher”，正常来说我们应该会依次经过5、6、7号节点，但是7号节点e后面没有r了！怎么办呢？我们可以构建一个 虚点 ，就是一个不存在的点，把它当作一个r来用，事实上，我们在构建字典树时，就已经建立了任何节点和任何节点的虚点连接，只不过没有指定编号而已。 好了，当我们构建完虚点时，我们是需要求出其 值的，把它当作一个正常的点。当虚点失配时，我们跳到其 的位置，尽管这可能是根节点，但总有巧合呢？例如，在图2中7号节点e下建立一个虚点r，它正好与4号r节点匹配，那么虚点的 值就等于 ，我们就相当于给4和7连接了一条 虚边 ，以后失配后就有办法解决了，只要从7号e跳到4号r即可。读者可以结合图4辅助理解。 图4 build函数的代码基于p1中关于 数组的方程，以及p2中构建转移边的思路，而在实际代码中，我们采用 广度优先搜索（BFS） 的算法来编写，这也很好解释：我们对 求值，是要从根节点开始（根节点的 值是 ），一层一层向下遍历的，因为前面我们的方程是基于 我们全部知道该层所有父亲节点的 值 这一事实来求的，所以我们一次就遍历一层。先看代码。 注意这些问题。 为什么我们不把根节点加入队列，而是从第一层（ 表示根节点的孩子，即第一层）开始插入？思考这样的问题，我们期望第一层所有节点的 值是多少？肯定是 吧，因为在第一层就失配，那么就直接返回根节点重新匹配即可。 但注意，我们的代码中，while循环里的每一次遍历，都是在计算当前节点的 下一层 的 值。那么从根节点开始呢？我们在计算第一层（也就是根节点的下一层）时，根据代码， （ 是第一层的一个存在的节点，称为 实点 ），也就是说，第一层的所有结点的 值都等于自身，这显然是荒谬的！但是从第一层开始遍历，由于值都是 ，所以不会算错后面的节点。 for循环中的if判断在干什么？首先，如果 不为 ，即指向字母 的 的孩子存在，是一个实点，那么我们按照方程求值，并且将得到的实点加入队列，进入下一次bfs. 那么反之，即 是一个 虚点 ，那么我们应该遵从p2的思路，建立虚边。由图4得到，我们这条虚边，应该将这个 虚点 和 其父亲回跳边节点的孩子 连接，得到上述代码。 我们可以思考一下，我们的操作其实同时在操控两个点，一个是我们遍历的点 ，另一个是其回跳边的节点 ，那么事实上，我们即使建立了虚边，但仍然满足上述提到的一个性质：从根节点到 的串仍是 的最长后缀，因为 的定义如此，所以虚边也是满足的，毕竟虚边也是根据 方程建立的。 查询（query） 最后一步其实因题而异，但大体相同，都是一样的结构：一个指针负责遍历主串，另一个指针从前者的字符开始，不断沿着回跳边搜索模式串，直到匹配成功或是回跳到根节点（例如需要统计次数的题，需要全部计算，要一直跳到根节点，保证没有漏解），然后重复这个过程，遍历完主串为止。 我们以一道例题来讲解query函数，此为题目传送门：here 题意为求解有多少个不同的模式串在主串中出现过，同一个但出现多次也算。那么我们只需要在query函数中，每次匹配成功时，将答案加上该节点是否为结尾节点即可。代码如下，后附一张模拟图，便于理解。 模拟图还是等下再放吧。先读懂代码再说。我们用指针 扫描主串 ，接下来另定义一个指针 ，看到for循环括号内的条件 且 ，条件 表明 ，也就是 没有回跳到根节点。我们将 一路顺着回跳边搜索，这样做是为了什么？根据题意，我们要统计所有不同的模式串，如果 ，那么说明 这个节点作为了若干个相同的模式串结尾，又根据 的定义， 的字符和 相同，所以一定也有串以 的字母结尾，那么我们沿着 上跳就是为了统计所有重复的模式串。 你应该还有个疑问：为什么 会等于 ？这是因为我们虽然要统计重复的，但不能在同一个节点计算多次，所以需要一个标记来记录， 即是次数记录，也是标记数组。 需要注意的是，既然 变成了次数，那么插入函数insert中 ed[p] = 1 就应该改为 ed[p] ++ ，我们在统计次数。 总结出来，我们的策略为： 指针 扫描主串，沿着 树边 或 转移边 走，保证不回退。 指针 沿着 回跳边 搜索模式串，每次从当前节点走到根节点，把当前节点中所有 后缀模式串 一网打尽，保证不漏解。 扫描完主串，返回答案。 如果读者想不明白，那么可以参考下面模拟图。 模拟图 关于虚边虚点的其他FAQ 但是可能有的读者还会有一个问题，虚边和虚点到底有什么用呢？事实上，虚边在AC自动机中起到了至关重要的作用，它保证了我们能够沿着回跳边搜索到所有的模式串，而不仅仅是那些在字典树中存在的模式串。 反正到这里我有两个疑问。 虚点的 值不也是虚点吗？那么沿着虚点上跳，不是一定回到根节点吗？那所有的虚点 值不都是 吗？这样做有什么意义？ 来，看图，红色箭头表示虚边，红圈为虚点，绿色边为回跳边，灰色点为一个模式串的结尾节点（即 的点）。 Cute_zsz画风诡异的图 现在假设我们要匹配 “shes”，显然我们会走到7号节点，然后走向虚点编号为12的s上。思考它的 值是多少？由图知，它的 应该是其父节点7号e的 值的13号虚节点s，那么 ；继续思考， 是多少呢？根据图片，它应该等于其3号父节点e的 节点，即1号e的虚点s编号，所以 ……这样的过程是循环往复的，但是直到14号节点，我们发现，它的 节点竟然是5号s节点，是一个实点！这就是说，在偶然的情况下，我们的虚点会沿着虚点的 值上跳，其又会沿着其 的节点上跳……循环往复，最终可能到达一个实点，从而匹配成功。 在匹配时，我们的指针 （当前遍历主串的编号）何时会回到根节点变成 呢？我们回到上面的那张图，关注主串的 “ya” 和后面的 “sher” 部分。 考虑指针 遍历到第一个 ‘a’ 的情况，假设模式串中也添加了一个 “a” ，那么我们的编号 就会走到11号节点，接下来和 ’s‘ 匹配，如图5. 图5 但是没有模式串 “as” 呀，意味着15号s是一个虚点。回到主串，接下来我们期望赶紧放弃a这个字符，直接跳到下一个s。我们的代码是怎样做的呢？回到图5，显然15号s的 节点是5号s，而5号s的 节点就是0号根节点，所以我们的 就回到了根节点，开始下一次搜索了。 这说明， 当我们想要结束匹配时，当前字符的下一个字符不会是当前字符在Trie树上的实儿子，而是一个虚点，其最终会回到根节点，开始下一轮匹配。 下面是例题的完整代码。 顺应着上面的思路，读者不妨理解思路后自己动手写一下。 结语 呼~写完啦，已经有7k字了……这应该是我第一次挑战这样一篇长的算法文章，博主还要上学，只能写完作业独自码到深夜…… 如果大家对这篇文章有疑问的话，欢迎留言。当然这篇文章肯定也有不足之处，希望读者多多指出。 写算法笔记的初衷是想让未来AFO的我还能看着这些旧时的文字，也许还能回忆起来以前OI的时光，也是学完算法做一个快速的复习，本篇文章其实更多是我的理解，我也不太清楚他人是如何讲述的AC自动机，但我们可以一起进步！ 事实上写这样一篇文章还蛮不容易的，讲清楚很难，同时还要在边写的时候质问一下自己：你真的理解了吗？有些问题可能我还没有指出，有些问题也许我也没有想到，但我想未来某一天，我会逐渐理解。 后续我会编写优化AC自动机的算法，即 失配树优化 ，也会带来更多趣题题解，敬请期待！"},{"title":"【题解】P14954 520","date":"2026-01-09T13:22:13.000Z","url":"/2026/01/09/520/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["题解","/tags/%E9%A2%98%E8%A7%A3/"]],"categories":[["undefined",""]],"content":"更好的阅读体验：here 题目传送门：here 明晰 长度为 的字符串 ，可以添加 个 ， 个 ， 个 ，现在求修改后字符串中 连续 的 串的数量。 （本蒟蒻最初读假题了） 思路 正解应为贪心，思考三种情况： 当前 串是完整的，那我们肯定不能动它； 当前 串只缺一个数，比如 、、 这样的，我们可以消耗一个贡献增加答案； 缺两个，也就是只有一个数，这样性价比最低，所以我们最后处理它。 那么思路大概就成形了，需要额外注意的是，在代码中，我们先去处理前两种情况。完整的好办，在循环中处理；缺一个的我们判断出来后，我们开三个变量分别统计三种情况，随即分别判断该数量与其缺少数组的最大添加数（也就是、、），尽我们所能贡献答案。 那么就只剩下只有一个数的情况了，我们可以单开三个变量去存落单（即没在前面被匹配）的数字个数，然后尽我们所能为落单的数作配对，直到再也没有闲置的数字或我们添加数字的机会用尽。 最后但同等重要，不要忘了剩下的机会仍可能能创造新的 串，答案需要加上。 读者不妨仔细思考上述过程，亦或是看代码，可能会理解得更清楚。 代码 后记 感谢观看，如有不足之处，欢迎批评指出。 文：Cute_zsz"},{"title":"【数学史】第二次数学危机的产生和解决，与微积分初步","date":"2025-12-21T00:24:32.000Z","url":"/2025/12/21/%E3%80%90%E6%95%B0%E5%AD%A6%E5%8F%B2%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%95%B0%E5%AD%A6%E5%8D%B1%E6%9C%BA%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3%EF%BC%8C%E4%B8%8E%E5%BE%AE%E7%A7%AF%E5%88%86%E5%88%9D%E6%AD%A5/","tags":[["数学史","/tags/%E6%95%B0%E5%AD%A6%E5%8F%B2/"],["数学","/tags/%E6%95%B0%E5%AD%A6/"],["微积分","/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"]],"categories":[["undefined",""]],"content":"问题引入 在经典力学中，我们是用以下方法求瞬时速度的： 对于位移 ，定义 为位移的增量， 为时间的增量，则 为当前的速度，当 趋近无穷小时，上式即为当前的瞬时速度。 顺着这样的思路，如果我们要求函数 在某一点（）处的“瞬时速度”，也就是瞬时变化率时（可以理解成在这一点处切线的斜率），我们可以使用如下方法： 定义一个 无穷小量（无穷小亮） ，函数图像在点 和点 处的割线斜率为 ，无限缩小 ，则两点越来越重合至一个点，也就为在这一点处的斜率了，称为函数 在 处的导数。 用这样的定义，我们计算一下函数 在 处的导数： 即， 注意，我们在上式的分数中，约掉了 ，此时 ，但在计算最后一步时，我们又把 当成 又约掉了，难道 是个变量？ 英国大主教乔治·贝克莱（George Berkeley）提出了上述的质疑 （是的提出这事的竟然是个哲学家），当时微积分理论是不严谨的。 “依靠双重错误得到了不科学但却正确的结果。” 这是贝克莱对牛顿等人工作的评价，无穷小量在最初的微积分理论中一会说是 ，一会说不是 。无穷小量在当时的数学应用中，它必须既等于 又不等于 ，这样的矛盾被称作 “贝克莱悖论” 。 尝试对悖论做出解释 事实上，对于无穷小的悖论，早在遥远的古希腊时期就出现了，有心的读者应该了解过 芝诺（Zeno of Elea）悖论，他说的是： 古希腊英雄阿喀琉斯跟乌龟比赛跑，阿喀琉斯让乌龟10秒，当10秒到达时，阿喀琉斯开跑，每次阿喀琉斯尝试追上乌龟时，都必须先到达乌龟的出发点，但此时乌龟已经运动了（无论它运动了多么小），所以下结论——阿喀琉斯永远追不上乌龟。 显然这不合理，但芝诺那群人是真的很爱抬杠，他们试图证明时间不存在、空间不存在、运动也不存在。 我们需要尝试对悖论做出解释，否则这不就乱套了吗。 于是，事情的结局 直到19世纪20年代，一些数学家才开始关注于微积分、函数、乃至实数的严格基础理论，柯西（Augustin Louis Cauchy）等人开始了尝试，给出了 极限 的严格定义： 当有 波尔查诺（Bernard Placidus Johann Nepomuk Bolzano）给出了连续性的定义，柯西又对级数的敛散性作出诠释，他指出：无穷小量是极限为 的变量，它不会等于 ，但永远 小于任意给定的正数 。 19世纪70年代初，魏尔施特拉斯（Karl Theodor Wilhelm Weierstrass）、戴德金（Julius Wilhelm Richard Dedekind）也奠定了实数的严谨定义。 历经半个多世纪，基本上解决了矛盾，为数学分析奠定了绝对严谨的基础。 那么是如何解决的呢？ 如本章的标题，如果这篇文章仅仅到解决矛盾结尾，那其实没什么好看的，相信读者都会关心数学家们是如何解决的。 倒回到问题解决之前，我们主要面对的是下面这几个问题： 级数的敛散性 函数的连续性、可微性 积分的存在性 级数的敛散性 相信大家都听过这样的谬论：，仍有读者认为，这个公式是有意义的。的确，在物理等领域确实是有一定的作用，例如著名的《弦理论》中就大量使用了上述结论。 但这里是数学，是严谨的、确定的一门理论科学中，在数学中，这样的式子是荒谬的。 原因是什么？ 我们从这样的求和开始，求： 考虑求和结果为 ，则有 ，约掉 ，即 ？ 这样的结果显然是荒谬的，同理，若空出 项，也有 ，究其根本，这是因为级数发散。 对于级数的敛散，有如下定义： 定义 对于一个级数，若随着求和项数不断增加，最终和逐渐趋向于一个稳定值，则称级数 收敛，反之，若最终和震荡或最终为无穷大，则称级数 发散。 上面全是 的那个级数是发散的，柯西准则告诉我们，对于这样发散的级数，是不可以加括号列方程的，否则会出现无数荒谬的结果，感兴趣的读者可以独立推导 这样的式子。 关于判定级数是否收敛，我们有 达朗贝尔（Jean le Rond d’Alembert）审敛法（比值审敛法），其实际上是这样运作的： 设正项级数 计算其相邻两项比值的极限，即 若 ，则后面的求和会越加越小，最终和收敛，前面的有限项可以忽略（无论它多么大）； 若 ，则求和会越加越大，最终和发散； 但 ，级数的敛散性不好确定，不作讨论。 下面是一个例子： 已知级数 判断它的敛散性。 解： 计算比值极限 故原级数收敛。 除此还有许多审敛的方法。 函数的连续性、可微性 莱布尼兹（Gottfried Wilhelm Leibniz）对连续的定义十分潦草：笔不离开纸。 欧拉（Leonhard Euler）对连续的定义也不准确：函数可以仅用单一解析式表达。 这能算数学定义吗？ 在严格化的过程中，数学家们意识到我们需要给连续一个严谨的定义： 定义 一般地，称函数 在点 处连续，当且仅当 魏尔施特拉斯使用 语言表述： 使得有 就是说，在自变量逼近 时，函数值时时刻刻都逼近于 ，而不是形如 在 处那样跳跃的，那么就说函数 在该点 连续。 完美！但是当时的人们没有意识到，连续和可微的关系。 典型例子就是魏尔施特拉斯函数 其中 ， 为正奇数，且满足 该函数处处连续，但处处不可导。 这里可能引申出可导和可微的差异，不过在一元函数中，这两个概念等价，本文章先不讲解这些。 下面是证明其不可导的一个可行思路： 通过放缩，我可以找到两个趋近于 的两个不同数列，且他们作为函数自变量求导数时结果不同，这与可导的定义矛盾。 所以我们有最终结论：可导必然连续，连续不一定可导。 积分的存在性 圆的周长 ，这个结论是如何得到的呢？ 中国古代数学家刘徽提出了 割圆术 ，其思想可总结为：“割之弥细，所失弥少。” 刘徽进行了测量圆周率 的工作，具体方法为，刘徽画出圆的内接六边形，算出周长再除以 （周长公式），得到了圆周率的近似值，只不过精度极低。 于是他开始不断分割下去，十二边形、二十四边形……最终画到了3072边形 （早期肝帝） ，计算出圆周率处于 和 之间，这是符合现代数学的。割圆术的顶峰，在于祖冲之手画了24576边形（肃然起敬），成功得到了圆周率 的近似值，这也是刘徽思想，乃至中国数学的一大成就，值得尊敬。 这和积分有什么关系呢？刘徽的割圆术，就是数学接触极限思想的开始，通过无限地分割圆，将其分成无穷边形，那么结果就完全精确，这才是割圆术真正的本质。这样的思想相当领先，人类从这里第一次接触极限，最终奠定了微积分理论。 所以，本质上微积分就是一门分析学科，它涉及极限，对于研究函数的性质有极大的推动，其核心就是上文反复出现的 极限思想。那么本章的问题就可以引入了，如图1. 图1 曲线 如图，我们使用图形工具 Desmos 进行模拟积分过程，我们想计算其曲边与 轴围成的曲边梯形的面积，这时候割圆术思想就发挥作用了，我们不去直接计算曲边梯形面积，而用小矩形进行代替，这些小矩形面积之和，我们就姑且把它当作结果。 显然，这样的精度是不够的，那如果我们不是像图中只使用4个矩形近似呢？如果10个、100个、1000个呢？ 如图2 图2 我们使用了10个小矩形进行计算，可以看到曲边梯形的面积已经近似得有模有样了，紫色是真实面积，绿色是我们的近似面积，可以看到，近似值为 ，而真实值为 ，进一步接近了，下面看图3. 图3 可以看到，面积已经非常接近了，这样看来，我们把矩形的数量不断叠加，面积就会越来越接近真实值，在无穷逼近后，近似值就一定和真实值 完全相同，这是多么重大的发现！下面我们来形式化地把计算写成数学语言。 定义 若函数 在区间 上有定义，将区间分割成 个子区间，每个区间长度为 ，并在每个子区间中任取一点 ，则函数 在 处的 叫做函数 在 处的 黎曼（Georg Friedrich Bernhard Riemann）积分（定积分），其中 。 直观理解，在子区间内取的任意一点 的函数值 相当于当前小矩形的高，而区间长度，也就是底边的长度，就是宽，它们相乘即为该小矩形的面积，最后把所有小矩形加起来，并且保证小矩形的 最大宽最小（极限式的意义），那么我们就把面积求出来啦！ 关于积分，其实还有一个 勒贝格积分 的定义，这个我们以后再说。 下面我们该讨论一下积分的计算了，一般地，对于黎曼积分，我们有如下定理： 定理1——拉格朗日中值定理 若函数 在 处连续，且在 处可导，则一定 有 其中 是函数在区间 处的 割线斜率 。 其本质上就是说，函数的平均变化率一定与某一样本相同，你可以把它当成一个物理问题：考虑小车的速度函数 ，则一定有一个时刻 的速度与平均速度 相同。 定理2——微积分基本定理 微积分基本定理（牛顿-莱布尼兹公式）： 若函数 是连续函数 在区间 的一个 原函数，则有 其中 表示函数的 一阶差分，即 下面给出证明，如图4，我们画出直观图像，图片来源于B站up主轩兔。 图4 上面的函数 的导函数为 ，这是它们的图像，那么定理就是说：下面图像带颜色的一部分的面积，等于上面原函数 在两点间的函数差值。 如图5，我们划分区间。 图5 我们划分一下区间，对于图中我们选定的一段子区间，记长度为 ，区间断点函数值的差分为 ，过区间端点作一条割线，割线的倾斜角 的正切值可以写成 ，如图6 图6 同时这条割线的斜率又可以使用内部的一个点 的切线斜率（拉格朗日中值定理）来表示，即 ，也就是 这样，对应到函数 上，恰好满足黎曼积分的定义：我在 的区间 找到了一个子区间，同时选取了点 ，与区间长度 相乘后，又恰好等于函数在该子区间值的差分 ，那么证明完毕！如图7所示。 图7 本章题目问题 过去关于积分的主要争议为：我们进行积分，其实是用几何的直观感觉解决数学问题，并没有确定什么样的函数是可积的，缺乏一个明确的判定标准。 但是，经过我们上文柯西等人对积分的严格定义，我们已经严密地建立了 微积分 这一概念（当然是一元函数的微积分初步），已经可以尝试直面第二次数学危机的质疑了。 基于黎曼积分定义后的积分，直观理解当然是面积的计算，但其根本，已经转化为了更加广泛的代数领域问题，至此，第二次数学危机被聪明的数学家化险为夷。 感叹，进步，与驻足更远处 引用百度百科的介绍， 这次危机不但没有阻碍微积分的迅猛发展和广泛应用，反而让微积分驰骋在各个科技领域，解决了大量的物理问题、天文问题、数学问题，大大推进了工业革命的发展。就微积分自身而言，经过本次危机的“洗礼”，其自身得到了不断的系统化，完整化，扩展出了不同的分支，成为了18世纪数学世界的“霸主”。 同时，第二次数学危机也促进了19世纪的分析严格化、代数抽象化以及几何非欧化的进程。 也许这次危机，我们有所收获的，不仅是更加严格、更加严谨的数学，也是人类对知识渴求的无畏和勇气。 文：Cute_zsz"},{"title":"【笔记】Trie字典树学习笔记","date":"2025-11-23T12:18:17.000Z","url":"/2025/11/23/Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["教程","/tags/%E6%95%99%E7%A8%8B/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"引入 在字符串集合 中查找 模式串 ，我们会使用 字典树 算法来解决形如这样的问题。 字典树（以下简称Trie）是一棵多叉树，为处理字符串而生，若使用红黑树等算法解决上述问题，则时间复杂度为 ，其中 ，这是因为比较两字符串是否相同仍需要依次比较。 那字典树的复杂度呢？仅为 ！！！（不是阶乘，仅表示感叹） 那这么牛的算法，原理是什么呢？ 原理 具象化上文的问题：给定字符集合 ，查找模式串 是否存在。 从一个简单的例子开始思考，，模式串待定。 如图，我们构建一棵树，每个结点编号为一个字符（形式上），第一层为每个字符串的首位组成的集合，第二位为每个字符串的第二位组成的集合……将每个字符串的下一位和上一位相连形成父子的关系，那么树就构建好了，复杂度为 较为可观，下面思考查找方式，假设我们要查找 . 建立一个数组， 表示 ， 表示当前节点编号为 时，在字符集中对应为 的字符的编号，当然 是个数字，我们要将字符集映射到数字，例如将a映射为1，b为2，等等。 令根节点root的编号为0（为1也行随便你），按照字典树建树的顺序进行编号，则可以转化成下面的图： 观察，我们要查询ab，首先找到首字符a的编号，即 （a映射为1，root是初始编号），并从这个点开始往下走，即遍历 （b映射为2），随后层层递进。 但是仔细想，仍存在一个问题，我们没法保证 在集合中一定存在我们的模式串。什么意思呢？ 假设字符集合中没有ab这个字符串，即没有 ，那么我们的程序会怎么样呢？ 按照刚才的流程，我们会从a开始，往b走……等会儿？不是说没有ab吗，为什么还会遍历到？ 再一观察，我们的字符集合中包含了abc这个字符串，查找时确实会遍历ab，造成好像存在ab的假象。 那么最后一个思考点就出来了，我们只需要对于一个字符串（字符集合中的），将它的结尾打一个标记，表明：存在一个字符串以当前字符结尾，那么问题就迎刃而解了，我们查找ab时，我们找到了b，但发现并没有打上标记，那么下结论：ab不存在！ 所以，记数组 （ 意思同上）， 表示编号为 的结点是否成为了某一个字符串的结尾。 那么思路分析到此位置，下面进入代码部分！ 代码 纯代码： 下面是洛谷的字典树模板： 代码如下： 值得注意的是，这道题需要你求以模式串作前缀的字符串数量，那么这时的 数组就没必要开成布尔数组了，可以直接记录个数，而且也不需要让字符作为结尾了，对于遍历到的每一个字符都加1，这样就是个数了，到时候直接查询即可，不需要求后缀和。 另一道例题： 也没啥，比上题还简单。 小结 字典树算是提高组较为基础的算法，其更进一步，就是AC自动机了。 期待下一次相遇，讲得不好，请多多指正。 文：Cute_zsz"},{"title":"【CSP-J 2025第四题 题解】多边形（polygon）","date":"2025-11-02T08:43:51.000Z","url":"/2025/11/02/2025%E7%AC%AC%E5%9B%9B%E9%A2%98%E3%80%91%E5%A4%9A%E8%BE%B9%E5%BD%A2%EF%BC%88polygon%EF%BC%89%E9%A2%98%E8%A7%A3/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["题解","/tags/%E9%A2%98%E8%A7%A3/"]],"categories":[["undefined",""]],"content":"更好的阅读体验：第四题】多边形（polygon）题解/ 题意 传送门： 题目描述 小 R 喜欢玩小木棍。小 R 有 根小木棍，第 () 根小木棍的长度为 。 小 X 希望小 R 从这 根小木棍中选出若干根小木棍，将它们按任意顺序首尾相连拼成一个多边形。小 R 并不知道小木棍能拼成多边形的条件，于是小 X 直接将条件告诉了他：对于长度分别为 的 根小木棍，这 根小木棍能拼成一个多边形当且仅当 且所有小木棍的长度之和大于所有小木棍的长度最大值的两倍，即 。 由于小 R 知道了小木棍能拼成多边形的条件，小 X 提出了一个更难的问题：有多少种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形？你需要帮助小 R 求出选出的小木棍能够拼成一个多边形的方案数。两种方案不同当且仅当选择的小木棍的下标集合不同，即存在 ，使得其中一种方案选择了第 根小木棍，但另一种方案未选择。由于答案可能较大，你只需要求出答案对 取模后的结果。 输入格式 输入的第一行包含一个正整数 ，表示小 R 的小木棍的数量。 输入的第二行包含 个正整数 ，表示小 R 的小木棍的长度。 输出格式 输出一行一个非负整数，表示小 R 选出的小木棍能够拼成一个多边形的方案数对 取模后的结果。 输入输出样例 #1 输入 #1 输出 #1 输入输出样例 #2 输入 #2 输出 #2 说明/提示 【样例 1 解释】 共有以下 种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形： 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 。 【样例 2 解释】 共有以下 种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形： 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 ; 选择第 根小木棍，长度之和为 ，长度最大值为 。 【样例 3】 见选手目录下的 与 。 该样例满足测试点 的约束条件。 【样例 4】 见选手目录下的 与 。 该样例满足测试点 的约束条件。 【子任务】 对于所有测试数据，保证： ; 对于所有 ，均有 。 测试点编号 思路 设性质，，其中表示多边形的边数，表示选定边的长度和，表示选定边长度最大值。 考虑全集，表示所有选边的情况，则全集的方案数为。 正向求解发现较为困难，于是反向求解，正难则反。 要求所有满足性质的方案数，我们可以转而去求不满足性质的方案数，使用全集方案数减之。 即答案集合. 所以只要想办法求出每一个集合对应的方案数即可。 现已知方案数（下同）， 接下来考虑，即对于任意条边，我选择条，则. 再下来，考虑的意义：既满足性质，又满足性质的情况集合， 可以这么考虑，首先，当时，因为全集中包含了，即任意边都不选的方案，故方案数加； 当时，任意选定一边，其和等于自身，其最大值也等于自身，故记为一种方案，由于有条边，则方案数为； 当时，考虑选定边权和，不妨设，当时，满足，故满足， 当时，不等式显然成立，故记为方案，方案数为. 所以. 接下来我们就要求最困难的部分了，即，考虑其意义：所有方案的集合，满足， 也就是说，我们要选定条边，设边集为，则要保证， 也就是说，我们要在一定的空间限度内，选择任意条边，并求出方案数。 思考一下，这是什么？这是背包算法，对吧？ 那么思路就顺过来了： 排序数组，枚举（）作为最大值的下标； 得到后，设表示对于前小的边，此时的总和（即上文中的）为时的方案数； 那么下面我们要考虑一个难题：如何保证背包一定要选择这条边呢？ 我们枚举这个，就是为了将其作为最大值考虑，那么背包是一定要选入这条边的。 很简单，只要最后我们求到作为最终状态即可，为什么呢？ 我们对不等式变形：，即我们故意不选择，但最终背包容量变成而不是. 能理解吗？这里需要想清楚。 一切准备就绪，则. 那么一切就结束了，由上知 接下来求出答案即可，上代码。 代码 自认为较为简短，记得取模。 需要注意的是以下几点： 数组需要赋初值，，这是因为这些状态都满足性质； 由于是方案数背包，故转移时要加上状态； 的范围不仅限在，因为表示，即木棍长度之和，就够用了； 45行加，是因为还没有考虑的情况。 至此，这道题目就讲完了。 若有疑问，可以私信或评论，我也会尽我所能答疑。 后记 本蒟蒻J组考场上也不高，只拿了340pts，若文章有错误，望能多多包涵并指出，我会改进。 最后： 祝大家CSP-J都取得理想的成绩！Bye(●’◡’●)！ 文：Cute_zsz"},{"title":"csp2025游记及一些碎碎念","date":"2025-11-01T12:08:21.000Z","url":"/2025/11/01/csp2025%E6%B8%B8%E8%AE%B0%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["生活游寄","/tags/%E7%94%9F%E6%B4%BB%E6%B8%B8%E5%AF%84/"]],"categories":[["undefined",""]],"content":"从初赛说起 好久没更新，其实不能怪我，去忙csp复赛了，今天刚考完，赶紧写出来。 从初赛开始讲吧， 本人蒟蒻，现在初二，知识没学多少，做题纯靠蒙， 于是最后J初赛93，S组66。 emm，S考的我其实不太满意，不怕笑话，第二大题阅读程序的第二问， 判断题 √×√ 我做的 ×√× 完美避开答案，回忆起来真是糖丸了我敲。。。 但还是过了，接着就准备复赛，鉴于去年的优异成绩 （210/235一等线），只好努力备赛S组（？） 是的 J怎么样已经不在乎了，反正明年初三再就不打了。 这样吧，初赛也就草草结束了，顺便我当天发着烧去的，感受到debuff加成了。 时间线变动 接下来就是准备 刷题 学习，还去杭州集训了，详见博客第二篇。 这回真的是all in了，国庆没做作业没复习，开学月考自然一塌糊涂，都快跌出前100了。 尤其考前两周，整个人就是疯狂做题状态，基本完全舍弃文化课了，偏偏新营作业还多学习还紧，我的班也是年级第一的班。 所以压力是很大的，成绩也在退步。 但现在看也还好，我心态变了吧，把成绩放在第一位什么，真没必要，点名某陈姓语文老师。 讨厌的班主任也在支持我，可能我真的在变强？ 存疑。 所以就这样到了day1 上午普及组 前一晚去试机（其实就是和朋友见面），熟悉了考场。 签到签到！来到考场，开始上午J组考试， T1水直接切（它保证了存在1~9的数，不需要特判） T2说来惭愧，数组开小了，调了半小时（苦笑） T3一眼dp，状态方程也很好写，但细节问题有待商榷， 所以先暂时瞄一眼T4吧。 T4一眼。。。。好吧没思路，所以直接暴力走起，40pts状压拿下。 回到T3，此时思路也有了，现在只考虑优化就可以了， 苦思。。。最终想到性质： dp数组单调递增，找前面dp最大值答案一定不会更劣， 于是大样例拿下， 很充实的一场比赛。 出去看到大佬ssy正在哭自己T3没调出来，这个人又在装13了（笑） 心情比较好，回家休息。 但突然不太舒服，这个留到下午再说。 下午提高组 上文的担心还是发生了。 首先不太好的是，上午水杯落在考场了，结果还锁门了，只能考完拿了。。。 拿到题目，好，T1就没思路。 其实不是没思路，贪心后反悔嘛，但正确性考场上真的没多想。。。 其实要证一证，要不然就对了，索性dfs骗60pts。 剩下三题：请输入文本。 是的，毛都不会，我真是傻逼完了。 交流 大家都好强啊，但说真的，考场上有一种超脱自己力量的无力感，很崩溃。。。 ssy和mzy大佬估分都160，我天还有人类吗，我还是太菜了。 所以说，这种东西还是别乱比了，看着就难受， 想来也能解释（），我还比大佬们小一年级，一年的时间还是能长进的嘛， 你像去年的我，肯定也是被现在的我甩去一大截，所以也不用太焦虑。 想说的话都留到结尾了，接下来会写赛后题解，尽情期待。 结语 距离退役还有几年呢，但几年，也就恍惚过去了。 至此，我该怎么评价我的OI生涯？ 也许这个问题对我还太早，你看这些深沉的文字，都是退役后再去写的。 但我也不希望我迷失在这条路上。 我应该刷题，应该训练，这些事我是知道的。 所以不要想那么多，我就算再糖，我也不是那种真不知道学习的，机会总是有的。 爸妈也挺佛系的，分数不重要，重要的是我， 但我还想继续走下去。 文：Cute_zsz"},{"title":"【笔记】KMP学习笔记","date":"2025-10-16T13:35:05.000Z","url":"/2025/10/16/KMP%E7%AC%94%E8%AE%B0/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["教程","/tags/%E6%95%99%E7%A8%8B/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"引言——字符串匹配问题 本文将记录我对KMP算法的理解，下面进入正题。 字符串匹配问题：给定字符串和字符串，询问是否出现在中， 或者说，是否是的子串，如果是，那么出现在哪个位置？ 这就是字符串匹配问题，其中称为主串，称为模式串。 字符串匹配应用广泛，现代算法对于文章中查找字词的一类，KMP基本是效率较高的一类了，一般复杂度为。 友情链接 这篇文章受此视频启发： 【KMP 学一遍忘一遍？ACM 金牌选手用可视化直击本质，理解了内核后想忘记都难！】 准备工作 对于字符串，规定其下标从到， 定义表示截取下标的位置，其中最长的不包含自身的公共前后缀的长度。 例如：字符串：abacab的nxt数组内容如下， （不包含自身）， （‘a’‘b’）， （‘a’‘a’）， （没有公共前后缀）， （首尾相等）， （abab）。 思路 上文的准备后，继续下一步。 现在将模式串和主串用一个特殊字符（可以是#、&amp;这样的）连接在一起。 形成模式串+'#'+主串的格式。 下面是最关键的一步。 对于拼接好的字符串，我们求一遍nxt数组， 结论：在’#'符号后面找到一个，若等于模式串的长度，则是模式串出现的位置。 证明 考虑找到（为模式串）时，表示：截取模式串到当前第i位的字符串，最长的公共前后缀的长度是多少。 首先，不可能大于#号的位置，后续这个字符没有出现。 那么一但，则表明的后缀和模式串匹配了，也就是模式串在#后的主串中出现了，符合问题的需求。 代码 有不明白的可以看注释，可以结合视频辅助理解。 结语 KMP可能是一道坎吧，总是看了忘忘了看，希望本篇从另一个视角出发，能带给你更深的理解。 文：Cute_zsz"},{"title":"Visual Studio Code 安装和使用教程","date":"2025-10-06T06:18:55.000Z","url":"/2025/10/06/%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","tags":[["教程","/tags/%E6%95%99%E7%A8%8B/"],["技术","/tags/%E6%8A%80%E6%9C%AF/"]],"categories":[["undefined",""]],"content":"前言 Visual Studio Code（简称 VS Code）是由微软开发的一款免费、开源的跨平台源代码编辑器。自2015年发布以来，VS Code已经成为了许多开发者的首选编辑器，它支持Windows、Linux和macOS操作系统。VS Code以其丰富的功能、高度可定制性以及广泛的语言支持而受到开发者的青睐。包括博主本人也在使用这个软件去编写c++、java、html、node.js等代码，综合来说，这个软件对于比较进阶的开发者（博主当然称不上）是比较轻便和易于使用的。本文将会带领你了解、使用，并爱上vscode。 警告 配置出问题是很正常的，如果你讨厌钻研自己学不懂的东西，那么现在就请退出。 准备 首先前往vscode官网： 点击右上角的“download”进行下载，根据你的电脑系统，选择不同的版本下载。 例如：如果你是windows系统，那么进入download页面后，就点击左下角写着“Windows”的蓝色按钮进行下载。 下载完后打开软件，进行安装，不要安装在C盘！impo 结束后打开软件，刚进入可能你会一脸懵逼： 怎么界面全都是英文？像我这样英语不好的怎么办？ 别急，接下来我们将要通过安装插件来解决这个问题。 ①切换中文 VS Code 的扩展功能和市场是其强大和灵活的核心特性之一，允许用户通过安装各种扩展来增强和定制编辑器的功能。 这是菜鸟教程上对vscode插件功能的介绍，vscode插件的功能很强大。 接下来我们来安装插件。 为了解决上述语言的问题，我们来安装简体中文插件。 首先点开侧边栏的插件图标，如图1.1， ​ 图1.1 如图，点击侧边栏左边的四个小方格图标，进入插件页面。 下一步，在搜索栏上输入chinese搜索中文简体插件，如图1.2， ​ 图1.2 点第二个中文（简体）插件。 安装完毕了，如何切换中文呢？ 先重启vscode，接下来按下Ctrl+Shift+P打开vscode上方的一条输入框，输入configure display language，点击下方出现的“切换语言”，切换中文，如图1.3。 ​ 图1.3 再重启vscode，就切换中文了。 ②安装c++插件 本栏以安装c++语言为例，教会你如何安装想编写的语言的环境。 现在我们要安装c++，所以再次来到插件栏，搜索c++，安装插件：C/C++，如图2，顺便可以装一个Code Runner。 ​ 图2 安装完毕后重启vscode。 ③安装minGW编译器 编译器是一种软件程序，主要功能是将用高级语言编写的源程序转换成目标语言（通常是机器语言）的程序。编译器的作用可以简单理解为“翻译”，即将人类可读的高级语言代码翻译成计算机可以执行的低级语言代码。 接下来我们安装minGW编译器，它可以编译c++语言。 我们前往官网下载：Releases · msys2/msys2-installer (github.com) 注意，这里可能需要科学上网。 ​ 图3.1 如上图2.2，我们单击日期进入页面，如图3.2，安装这一个。 ​ 图3.2 注意：MSY32需要64位Windows 8.1及以上版本。 下载完毕后，我们点开软件，进行安装，这部分应该不用教了吧，不过个人推荐你的安装设置全部默认，安装路径一定要是英文路径！！！ 毕竟99%的错误都出自于路径设置成中文。 安装完毕后，将minGW下的ucrt64\\bin路径的那一长串复制下来（过会儿要用！） ④配置系统环境变量（最难一步） 可能有小朋友们要问了，什么是环境变量？ 简单来说，环境变量就是操作系统中用于说明运行环境的一些参数、变量。 可能学过编程的一些同学会更清楚一些，但这不重要。 接下来我们开始配置minGW的环境变量，这一步相对比较困难。 按下Win+S，会弹出一个搜索框，如图4.1，搜索”环境变量“， 图4.1 点进去，再点击”环境变量(N)“，进入图4.2的页面： 图4.2 如图所示，点击下方系统变量Path，再点击编辑。 将你上文中复制的编译器的路径粘贴进去，如图4.3。 图4.3 保存后重启，重启完后打开命令提示符，输入gcc -v， 如果输出类似下图，说明安装成功，如图4.4。 图4.4 到这里minGW的配置就大功告成了！ ⑤配置vscode环境 代码环境 到这里配置已经完成一大半了！接下来新建一个文件夹存放代码文件。 进入自己的文件夹，如图5.1，建立cpp文件。 图5.1 随后输入文件名，如图5.2。 图5.2 按下回车键，创建文件，随后输入代码，开始编程，如图5.3，我编写了一个简单的程序，输出Hello World! 图5.3 如图5.4，点击右上角的小三角图标运行。 图5.4 点击弹出的“C/C++: g++.exe 构建和调试活动文件”。 随后会生成.vscode文件夹，里面存放了task.json文件。 下面做的就是把文件中的&quot;command&quot;内的值改为你的路径，如图5.5。 图5.5 将图中红框的位置修改为你前面复制的编译器路径，注意路径不要有中文！，并且路径的分隔符一定是\\\\，不要写错了。 这样编译器路径就完成了，通常来说，你的程序现在就可以运行了。 调试 接下来生成调试文件，用于debug， 点击左侧侧边栏的调试图标，如图5.6。 点击“创建 launch.json 文件”，点击弹出的“另外C++（GDB/LLDB）”个选项，然后“C/C++:g++.exe 构建和调试活动文件”。 由于我已经配置过了，界面和大家的不一样，故不放图片。 随后点击右下角的添加配置，然后点击“C/C++:（gdb）启动”，对下面两个部分进行修改，如图5.7： 图5.7 上面的program里填入程序名，下面填入编译器路径，绝对和相对都可以。 至此，配置已经全部完毕。 后续我会更新一些别的语言的配置教程，以及个人主题的配置等，敬请期待。 后话 我是一直想写一篇vscode的教程，一方面带大家了解，一方面也为自己的新手时期做个交代，如果你对这篇博客有任何疑问，欢迎留言私信告诉我！"},{"title":"记我的国庆七天集训之旅（已完）","date":"2025-10-04T11:21:38.000Z","url":"/2025/10/04/%E7%94%9F%E6%B4%BB%E6%B8%B8%E8%AE%B0/%E8%AE%B0%E6%88%91%E7%9A%84%E5%9B%BD%E5%BA%86%E4%B8%83%E5%A4%A9%E9%9B%86%E8%AE%AD%E4%B9%8B%E6%97%85/","tags":[["信息学奥赛","/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%A5%A5%E8%B5%9B/"],["生活游记","/tags/%E7%94%9F%E6%B4%BB%E6%B8%B8%E8%AE%B0/"]],"categories":[["undefined",""]],"content":"Day0（9月30日） 和大佬ssy（shabi45，洛谷链接： ）商量好一起去杭州集训，一想到接下来的国庆7天都要在那里度过，竟然还有些期待（ 其实完全多虑了，基本是噩梦的开始。。。 下午请了假，匆匆赶到火车站赶车。 车上和大佬玩得还算开心，一下午的车程很快过去了。 到了杭州，有敬爱的NathanWong（王老师）接我们，好久不见，时间真的好快，上次他教我们还是去年cspj。 竟然到了杭州西站还要赶车吗。。。哈基王你这家伙（ 于是又和大佬匆匆赶了2h地铁，这就是大城市吗，畏惧了。。。 到了集训的酒店已经是晚上11点了，意外地一点也不困。 可惜手机还被收了。。 Day1（10月1日，下承） 昨晚得知好像每天都有一场模拟赛，对我这种菜狗太不友好了吧！！ 早上7点起床，纯纯集中营。 上午比赛的4h过去了，分数。。。极烂。 这么说吧，自我学OI以来就没打过这么烂的分了。 具体多少就不说了，反正我不是倒数就对了。 大佬shabi45还是一如既往的强👍。。。。 只好下午听课好好学习了。 认识了一下新的室友，别的寝室都是6人起步，就我们宿舍4人——但是， 来了个新舍友（虽然跟shabi45一样烦人。。。） ps：大佬shabi45像g a y。 挺好的，宿舍也热闹了，睡觉睡觉！ Day2 依旧模拟赛，和大佬坐一块，但分数。。。 还是不尽人意， 要好好学习。 结识了很多集训的朋友，监狱也可以快乐起来啊。。。 因为没收广告费，所以什么机构就不说了，纯私人。。。 老师下了禁令不让捎电脑回寝，但大佬非常勇啊， 还是带了，哈哈，也没被发现。 宿管的规律我们也都摸清了，byd我反侦察意识极强，躲了好几次（ 睡觉睡觉，明天再战。 Day3 今天的模拟赛总算正常了，295/400pts， 感觉算是个人类了。 因此下午过得很愉快，水水群 调调代码，比较充实。 这监狱生活也是好起来了。 最近几天一直构思着搞个自己的博客，感觉未来就是敲代码猝死的命。。。 今天没啥好说的，休息！ Day4 上午比赛平平淡淡，120/400pts，题有点难， 大佬还是很强，我还是很菜。 无所谓了， 因为今天终于把博客写出来了， 画画水平提升了，周围同学都开始夸了： 好看好看。 前四天的博客就是Day4晚上，现在的我敲的。 希望后几天越来越好。 Day4.5 半夜了我他妈还在这里写我博客的代码， 累死人了，怎么能有这么难搞的东西， 搞个评论功能差点没给我累死。。。 等我搞完了一定再写一篇博客记录一下开发历程。 Day5 上午出的什么78题目，四道题两道概率， 很难想象是给人类做的。 旁边yhm对着T3摁做了1h，结果发现如果不是递归函数写错了负负得正，甚至没一个对的，没绷住（乐） 现在切了T1，打了T2 T4的暴力，T3题都看不懂就算了吧。。。 等中午出分了再回来细说。 出分了，依托，最高才150，我90/400pts。 考试时候脑子犯蠢，没看到T1的n&lt;=1e6，开了1e5。。。 后悔死了，要不然上百了。 旁边yhm，T1把freopen写主函数外面了，没绷住。 搏一搏，100pts变0， 今天争取给评论写出来， 我是比较青睐valine的，但是配置真的好麻烦。。。 emm 评论功能基本算是写好了，但是还是有点小bug。。。 晚上再改吧，晚自习现在可累了。 bye Day6 中秋节快乐！ 上午模拟赛爆炸了，T1没想到那个性质—— 二进制运算在多次之后是不会产生新的数的了， 我草，真糖丸了。。。 中午吃饭，得知大佬也没想到思路， 今天估计就70pts了， 啊啊啊啊啊， 周围人都比我高啊啊啊， 看完分了，甚至比70低，没救了。。。 下午好好学习吧，不水博客了。 得知10.7下午就要走了，和室友要再见了， 晚上和大佬以及他爸妈出去吃了顿火锅(●ˇ∀ˇ●) 可以逃晚自习了，爽。 Day7 收拾好行李，准备走了，再看一眼寝室。 把行李拿上后上楼，搞笑的是差点没老师上不去电梯，所有人都困在1楼了（乐） 神必东西最后一天还有模拟赛，真唐丸了。。。 得知下午不用上晚自习了，呃呃呃。 寝室合照 ↓ （从左到右：xgl、jdz、yhm、zsz、ssy） 上午比赛还可以，250/400pts，比大佬高10，险胜险胜。 下午可以摸鱼了，不用上晚自习， 差不多5点半就可以回去了，7天过得还挺快的。 下午五点半出发，大佬他爸开车送我们俩，他和他弟可闹腾了， 睡了一下午，到凌晨，开始补番。 看的是春物，《我的青春恋爱物语肯定有问题》 好看，我是雪之下雪乃的dog。 Day7.99 这里是凌晨的Cute_zsz，幸好下午睡了一会儿，晚上别人都睡了， 我可以留足精力看番，还不会很吵。 到凌晨两点差不多就到家附近了，谢谢叔叔开车送我。 爸妈来接我了，这魔鬼七天终于结束了。 放心，明年国庆绝对不回来了，太地狱了。 游记就到这里，博主后天还有考试。 感谢你看到这里，如果喜欢，就评论支持一下吧！ 愿你有一个美好的一天！ byebye！(●’◡’●) 文：Cute_zsz"},{"title":"Hello, Blog！","date":"2025-10-04T06:20:41.000Z","url":"/2025/10/04/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E5%8D%9A%E5%AE%A2%EF%BC%81/","tags":[["博客日常","/tags/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8/"]],"categories":[["undefined",""]],"content":"总览 Hello, Blog! 我是Cute_zsz，是一名现役OIer，热爱编程、动漫和数学，现在上初二。 关于我的名字 Cute_zsz直译来是可爱的zsz（下划线！），zsz是我名字的缩写，Cute一词，来源于我的群友。群友把名字换成我的，造出了生气的zsz、可爱的zsz等杰作，群里面充满了快活的空气（） 我个人是比较喜欢Cute_zsz这个id，这也比较符合我二次元小登的形象（） 关于我的一些链接 luogu： github:  steam:  bilibili:  pixiv（？）： qq：951255007 微信号：Cute_zsz 上述群聊：323360503 结语 欢迎关注我的博客，目前博客可能在格式、文笔上有些瑕疵，也请大家多多包涵。有疑问欢迎联系我！ 最后，与诸君共勉。"}]